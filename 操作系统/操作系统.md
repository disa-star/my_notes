### 2.2线程

对于多线程  
a调用过程,过程写入errno,a读出errno判断结果  
b写入errno

在a的写入过后执行b  
导致b写入后更改了errno的值使得a错误执行

解决方法:

**全局变量管理器**

通过create_global('唯一id') 来创建一个全局变量  
而后写入使用的是 set_global('id',value)  
读出使用 a = read_global('id')

如果另一个线程用同样的代码访问了'相同id'的全局变量  
则会因为他们处于不同的存储单元而不会互相冲突

**不可重入**

第二次调用不可以发生在第一次调用结束之前

普通的解决方案:  
为每个过程使用一个包装器: 调用过程的时候检查包装器设置的值来看是否所有的其他调用都已经结束(类似于锁)

**线程专用信号**(?)

线程调用alarm的时候 内核不知道该传给哪个用户态线程

**信号处理的冲突**

有些线程想要捕捉ctrl c 而另一些线程想要用ctrl c终止整个进程

**堆栈管理**

用户态线程堆栈即将溢出时内核并不知情, 不能使他们自动增长  
最后会溢出

### 2.3进程通信

**竞争条件**

a读到ok后被cpu挂起  
b也读到ok , 紧接着b写入, b结束  
a同样写入相同位置, b被覆盖

称对共享内存进行访问的程序为临界区域

![Alt text](image.png)

解决方案:

屏蔽中断不好:  
1 万一搞错就会终结系统(单核)
2 多核系统中 屏蔽单个cpu不能阻止其他cpu访问

锁变量

轮换(令牌桶)  
容易出现某个进程被临界区外的另一个不想立刻进入临界区的进程阻塞

peterson解法

**TSL指令:读锁和写锁是不可分割的操作**

![](image-1.png)

**XCHG:原子化地交换两位**

![](image-2.png)

睡眠等待(挂起)  
设置一个睡眠量记录器(信号量Dijkstra):  
对一个应当睡眠的进程执行down则将信号量降低1  
如果信号量为0则将进程睡眠  
对一个应当被唤醒的进程执行up则将信号量+1  

down与up操作同样可以用在锁上  
生产者-消费者问题:内存满了生产者休眠 内存空了消费者休眠  
休眠的时机来自于信号量:空槽数 满槽数

其中 down up 与信号量的检测必须合起来是一个原子操作

**互斥量** mutex

互斥量和锁的区别:
enter_region会让取锁失败的线程永远循环 , 不给拥有锁的线程释放锁  
mutex_lock 在取锁失败时会直接thread_yield给其他线程

![Alt text](image-3.png)

**如何在进程之间共享重要的 互斥量 信号量等?**

1 信号量可以放在内核中 并只能通过系统调用来访问  
2 os提供了进程之间的共享地址空间 实在不行可以用共享文件

![Alt text](image-4.png)

pthread 的另一个同步机制 : **条件变量**  
允许线程因为一些未达到的条件而阻塞

![Alt text](image-5.png)

死锁的产生

生产者:先down empty再down mutex(进入临界区)  
消费者:先down full再down mutex 再 up empty

上面不会产生死锁

生产者:先down mutex再down empty  
消费者:先down full再down mutex 再 up empty

缓冲区满了后生产者卡在empty上  
而mutex也被设置为0 消费者卡在mutex上

产生死锁

**管程**

任意时刻中管程中只能有一个活跃进程

>典型的处理方法是，当一个进程调用管程过程时，该过程中的前几条指令将检查在管程中是否有其他的活跃进程。如果有，调用进程将被挂起，直到另一个进程离开管程将其唤醒。如果没有活跃进程在使用管程，则该调用进程可以进人

>进入管程时的互斥由编译器负责，但通常的做法是用一个互斥量或一元信号量。因为是由编译器而非程序员来安排互斥，所以出错的可能性要小得多。在任一时刻，写管程的人无须关心编译器是如何实现互斥的。他只需知道将所有的临界区转换成管程过程即可，决不会有两个进程同时执行临界区中的代码

除此之外, 还需要让进程在无法继续运行时被阻塞(生产者-消费者问题)  
引入条件变量:  
1管程过程发现它无法继续运行(如生产者发现缓冲区满)  
2该过程执行wait并等待一个signal  
3wait使自身阻塞并让另一个等待中的进程调入

4在其他管程过程发出signal后立即退出(相当于yield)  
5继续执行等待signal的过程

**条件变量没有办法存储信号量,因此signal必须在一个进程wait之后才能被接受**  
但可以在发送signal之前检查接收进程的状态来判断是否必要发送signal

>读者可能会觉得wait和signal操作看起来像前面提到的sleep和wakeup，而我们已经看到后者存在严重的竞争条件。是的，它们确实很像，但是有个很关键的区别: sleep和wakeup之所以失败是因为当一个进程想睡眠时另一个进程试图去唤醒它。  
>使用管程则不会发生这种情况。对管程过程的自动互斥保证了这·一点:如果管程过程中的生产者发现缓冲区满，它将能够完成wait操作而不用担心调度程序可能会在wait完成之前切换到消费者。甚至，在wait执行完成而且把生产者标志为不可运行之前，根本不会允许消费者进入管程。

>Java是一种面向对象的语言，它支持用户级线程，还允许将方法(过程)划分为类。只要将关键词synchronized加人到方法声明中，Java 保证一旦某个线程执行该方法，就不允许其他线程执行该对象中的任何synchronized方法。

如果真的需要用管程 , 就必须要使用一个支持了管程的语言

在分布式系统中:多cpu 多内存  
信号量的 TSL 和 XCHG 将会失效(但管程仍然可用?)

**消息传递**

解决生产消费者问题:  
类似于集装箱:  
消费者:只有在仍有内容消息时才能消费,并发送给生产者一个空消息  
生产者:只有在仍有空消息时才能生产,并发送一个内容消息

地址问题:  
使用进程编号 或是建立一个信箱地址  
信箱满后, 其他向此信箱发送的消息都会被挂起

![Alt text](image-6.png)

**屏障**

>在有些应用中划分了若干阶段，并且规定，除非所有的进程都就绪准备着手下一个阶段，否则任何进程都不能进入下一个阶段。

### 2.4调度

>进程切换的代价是比较高的。首先用户态必须切换到内核态，然后要保存当前进程的状态，包括在进程表中存储寄存器值以便以后重新装载。在许多系统中，内存映像(例如，页表内的内存访问位)也必须保存，接着，通过运行调度算法选定一个新进程，之后，应该将新进程的内存映像重新装入MMU，最后新进程开始运行。除此之外，进程切换还要使整个内存高速缓存失效，强迫缓存从内存中动态重新装人两次(进入内核一次离开内核一次)。

调度时机:  
- 创建新进程 运行父进程 or 运行子进程  
- 一个进程退出后 运行其他的就绪进程  
- 当一个进程因为I\/O而阻塞等, 选择其他进程运行
- 当一个I\/O中断发生时, 某个进程就绪了

非抢占式调度算法:让进程运行直到被阻塞 or 自己释放cpu  
在时钟中断发生时, 如果没有更高优先级的进程正在等待到时, 被中断的进程继续运行

抢占式: 分给每个进程一个最大时间片 , 到时间了自动被挂起, 以便把cpu控制还给调度程序

**不同的调度算法服务于不同的目的**

批处理:长时抢占式 和 非抢占式都可以接受  
服务器(交互式):抢占式(为了处理许多突发服务)  
实时系统: 非抢占式

![Alt text](image-7.png)

最短作业优先调度的方法只在所有作业同时就绪的情况下 平均完成时间最优  
最短剩余时间优先

轮转调度:相当于令牌桶 : 每个进程被分配一个时间片  
进程挂起时机:
- 用光时间片
- 阻塞

长时间片使cpu利用率更高  
短时间片让作业更公平  
并且如果时间片长于发生阻塞的时间, 则避免了抢占, 提高效率

优先级调度: 在滴答时降低当前进程的优先级, 如果当前进程优先级不是最高, 则挂起

nice命令更改优先级

**优先级类**

运行优先级 和 单次运行时间片长度成反比:  
如果在分配1时间片时消耗完毕 则降低一级优先级并分配两倍时间片

>对于那些刚开始运行一段长时间，而后来又需要交互的进程，为了防止其永远处于被惩罚状态，可以采取下面的策略。只要终端上有回车键 (Enter键)按下，则属于该终端的所有进程就都被移到最高优先级，这样做的原因是假设此时进程即将需要交互

![Alt text](image-8.png)

**最短作业优先** 实现方式

![Alt text](image-9.png)

**保证调度** 时间片为 1/进程数

![Alt text](image-10.png)

**彩票调度**

![Alt text](image-11.png)

**公平分享调度**

按照用户公平而不按照进程公平

#### 实时系统

硬实时: 不能错过任何ddl  
软实时: 允许偶尔错过ddl

周期事件: 如果 处理事件\*发生频率 的和 小于 1  
则称之为可调度的(此时假设上下文切换开销很小)

**调度机制和调度策略分离** 通过其他方法得知哪个子进程更为紧迫

```
实时系统缺乏一个时钟中断来让过长的线程自行结束
```

![Alt text](image-12.png)

50ms时间片分给进程A让A自由分配和  
内核级线程的类似调度

*从A1切换到A2比从A1切换到B1开销更小*

# 第三章存储

避免使用绝对的内存地址导致内存装载的时候跳到错误的位置  
使用静态重定位技术

>它的工作方式如下，当一个程序被装载到地址16 384时，常数16 384被加到每一个程序地址上。虽然这个机制在不出错误的情况下是可行的，但这不是一种通用的解决办法，同时会减慢装载速度

处理内存超载使用 **交换系统** : 把被挂起的进程的内存内容放在磁盘上

![Alt text](image-13.png)

这种方案会需要特别地去解决进程内存自动增长的问题  

>若该进程与一个空闲区相邻，那么可把该空闲区分配给该进程让它在这个空闲区增大。另一方面，若进程相邻的是另一个进程，那么要么把需要增长的进程移到内存中一个足够大的区城中去，要么把一个或多个进程交换出去，以便生成一个足够大的空闲区。若一个进程在内存中不能增长，而且磁盘上的交换区也已满了，那么这个进程只有挂起直到一些空间空闲(或者可以结束该进程)。

![Alt text](image-14.png)

因此os可以为增长预留空间  
但在交换时把预留的空间也全部交换出去是一种浪费

**记录空闲内存**

方法
- 位图法:按bit的倍数分割内存单元 用位图记录空闲状态(bit map)
- 使用链表记录 (空闲 or 占用) \| (起始位置) \| (长度) \| (下一个)
- 快速适配

![Alt text](image-15.png)

**虚拟内存**

覆盖

![Alt text](image-16.png)

**内存管理单元 MMU**

![Alt text](image-17.png)

页面和页框的大小通常是一致的  
此时 MMU 会把所有 0\~4095 的有效请求映射到 8192\~12287

当程序需要访问一个不在页框中的页面  
MMU缺页中断  
CPU陷入陷入操作系统  
选择一个页框放弃掉 并载入需要的新的页面  

以二的幂作为页框长度有好处:

![Alt text](image-18.png)

左侧的值被用作虚拟页面的索引  
右侧的值被直接复制到物理地址的映射

>例如，对于16位地址和4KB 的页面大小，高4位可以指定16个虚拟页面中的一页，而低12位接着确定了所选页面中的字节偏移量 (0~4095)。但是使用3或者5或者其他位数拆分虚拟地址也是可行的。不同的划分对应不同的页面大小。

![Alt text](image-19.png)

说明
- 在\/不在 位  
如果不在(0)会引发缺页中断
- 保护位 读 写 执行
- 修改位 :  
在重新分配页框时 如果一个数据已经被修改,那就必须要写回磁盘  
而如果只是读过了, 就只需要删除
- 访问位 : 为操作系统选择哪个页面应当丢弃时作为参考
- 禁用高速缓存位 : 保证能够从设备实时地读出内容而不是用缓存中的内容

为了降低**寄存器操作**时候对内存的访问  
(寄存器操作需要先查页表 而后才能知道具体修改哪个寄存器)

TLB 转换检测缓冲区 减少反复读取内存的开销(是硬件解决方案) 

TLB管理软件:  
同样为了减少TBL失效发生的概率(类似于缺页中断)  
发展出了TBL预测

![Alt text](image-20.png)

